scilla_version 0

import BoolUtils

library ZilPayValidator

let zero_address = 0x0000000000000000000000000000000000000000

(* Global variables *)
let zero256 = Uint256 0
let zero128 = Uint128 0
let zerobn = BNum 0

let one128 = Uint128 1

let one_msg =
  fun (msg: Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint256 = @option_value Uint256
let option_uint128 = @option_value Uint128

let percent_of_amount =
  fun (percent: Uint128) =>
  fun (amount: Uint128)  =>
    let n_100 = Uint128 100 in
    let value = builtin mul amount percent in
      builtin div value n_100


let bn_to_uint =
  fun (block_number: BNum) =>
  let int_block = builtin bsub block_number zerobn in
  let some_int_block = builtin to_uint256 int_block in
    option_uint256 zero256 some_int_block


(* Custom ADT storing - Title, ipfs_description, url, ipfs_image, ipfs_icon, category *)
type App =
| App of String String String (List String) String Uint32

(* Custom ADT storing - end_block_number, url, ipfs_banner_url *)
type AD =
| AD of Uint256 String String

type Operation =
  | Add
  | Sub

(* Error events *)
type Error =
  | CodeNotContractOwner
  | CodeOnPause
  | CodeNotValidator
  | CodeNotFound
  | CodeNotManager
  | CodeNotZLP
  | CodeInsufficientAmount
  | CodeIsNotOwnerOrOperator

let add_operation = Add
let sub_operation = Sub

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotContractOwner      => Int32 -1
      | CodeOnPause               => Int32 -2
      | CodeNotValidator          => Int32 -3
      | CodeNotFound              => Int32 -4
      | CodeNotManager            => Int32 -5
      | CodeNotZLP                => Int32 -6
      | CodeInsufficientAmount    => Int32 -7
      | CodeIsNotOwnerOrOperator  => Int32 -8
      end
    in
    { _exception : "Error"; code : result_code }

contract ZilPayValidator
(
  contract_owner: ByStr20,
  explorer: ByStr20,
  zlp: ByStr20
)

(* Mutable fields *)
field pause: Bool = False
field min_stake_amount: Uint128 = zero128
field rewards_fee: Uint128 = Uint128 10

field wait_list_app: Map ByStr20 App = Emp ByStr20 App
field wait_ad_list: Map ByStr20 AD = Emp ByStr20 AD
field ad_amount_list: Map ByStr20 Uint128 = Emp ByStr20 Uint128

field manager: ByStr20 = zero_address

field operators: Map ByStr20 ByStr20 = Emp ByStr20 ByStr20
field holder_list: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field total_validators: Uint128 = zero128

(* Emit Errors *)
procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsValidator()
  is_validator <- exists holder_list[_sender];

  match is_validator with
  | True =>
  | False =>
    err = CodeNotValidator;
    ThrowError err
  end
end

procedure IsZLP()
  is_zlp = builtin eq zlp _sender;

  match is_zlp with
  | True =>
  | False =>
    err = CodeNotZLP;
    ThrowError err
  end
end

procedure IsManager()
  address_manager <- manager;

  is_manager = builtin eq address_manager _sender;

  match is_manager with
  | True =>
  | False =>
    err = CodeNotManager;
    ThrowError err
  end
end

procedure isOwnerOrOperator(to: ByStr20)
  some_operator <- operators[to];

  is_operator = match some_operator with
    | None => False
    | Some operator =>
      builtin eq operator _sender
    end;

  is_owner = builtin eq to _sender;
  is_allow = orb is_operator is_owner;

  match is_allow with
  | True =>
  | False =>
    err = CodeIsNotOwnerOrOperator;
    ThrowError err
  end
end

procedure CheckAmount(amount: Uint128)
  min_amount <- min_stake_amount;

  is_min_staked = builtin lt amount min_amount;

  match is_min_staked with
  | True =>
    err = CodeInsufficientAmount;
    ThrowError err
  | False =>
  end
end

procedure CheckPause()
  curent_pause <- pause;

  match curent_pause with
  | True =>
    err = CodeOnPause;
    ThrowError err
  | False =>
  end
end

procedure IsContractOwner()
  is_contract_owner = builtin eq contract_owner _sender;
  match is_contract_owner with
  | True => 
  | False =>
    err = CodeNotContractOwner;
    ThrowError err
  end
end

procedure UpdateZLP(operation: Operation, address: ByStr20, amount: Uint128, current_count: Uint128)
  match operation with
  | Add =>
    new_to_count = builtin add current_count amount;
    holder_list[address] := new_to_count
  | Sub =>
    new_to_count = builtin sub current_count amount;
    is_zero = builtin eq new_to_count zero128;

    match is_zero with
    | True =>
      delete holder_list[address]
    | False =>
      holder_list[address] := new_to_count
    end
  end
end

procedure CallTransfer(to: ByStr20, amount: Uint128)
  msg_transfer = {
    _tag: "Transfer";
    _recipient: zlp;
    _amount: zero128;
    to: to;
    amount: amount
  };
  msgs = one_msg msg_transfer;
  send msgs
end

procedure ValidationRewards(ad_owner: ByStr20)
  some_amount <- ad_amount_list[ad_owner];
  percent <- rewards_fee;
  some_holder_amount <- holder_list[_sender];
  some_self_balance <- holder_list[_this_address];

  amount = option_uint128 zero128 some_amount;
  staked = option_uint128 zero128 some_holder_amount;
  self_balance = option_uint128 zero128 some_self_balance;
  rewards = percent_of_amount percent amount;
  is_zero = builtin eq self_balance zero128;
  new_ad_amount = builtin sub amount rewards;

  ad_amount_list[ad_owner] := new_ad_amount;

  e = {
    _eventname : "ValidationRewardsEvent";
    rewards: rewards
  };

  event e;

  match is_zero with
  | False =>
    UpdateZLP add_operation _sender rewards staked
  | True => (* Nope *)
  end
end

procedure SendAD(ad: AD, owner: ByStr20)
  msg = {
    _tag : "AddBanner";
    _recipient: explorer;
    _amount: Uint128 0;
    ad: ad;
    owner: owner
  };
  msgs = one_msg msg;
  send msgs
end

procedure SendApp(app: App, owner: ByStr20)
  msg = {
    _tag : "AddApplication";
    _recipient: explorer;
    _amount: Uint128 0;
    app: app;
    owner: owner
  };
  msgs = one_msg msg;
  send msgs
end

procedure WithdrawZLP(to: ByStr20)
  some_balance <- holder_list[to];
  validators <- total_validators;

  balance = option_uint128 zero128 some_balance;
  new_validators = builtin sub validators one128;

  total_validators := new_validators;

  UpdateZLP sub_operation to balance balance;
  CallTransfer to balance
end

procedure ValidationADReject(ad_owner: ByStr20)
  ValidationRewards ad_owner;

  some_amount <- ad_amount_list[ad_owner];

  amount = option_uint128 zero128 some_amount;

  CallTransfer ad_owner amount;

  delete wait_ad_list[ad_owner];
  delete ad_amount_list[ad_owner];

  e = {
    _eventname : "ValidationADRejectEvent";
    ad_owner: ad_owner
  };
  event e
end

procedure ValidationADSuccess(ad_owner: ByStr20)
  some_confirmed_ad <- wait_ad_list[ad_owner];
  current_block <- & BLOCKNUMBER;

  match some_confirmed_ad with
  | Some confirmed_ad =>
    match confirmed_ad with
    | AD block url banner =>
      ValidationRewards ad_owner;

      delete wait_ad_list[ad_owner];
      delete ad_amount_list[ad_owner];

      block_256 = bn_to_uint current_block;
      end_block = builtin add block_256 block;
      new_add = AD end_block url banner;

      SendAD new_add ad_owner;

      e = {
        _eventname : "ValidationADSuccessEvent";
        new_banner: new_add;
        current_block: current_block;
        ad_owner: ad_owner
      };
      event e
    end
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

procedure ValidationAppSuccess(app_owner: ByStr20)
  some_confirmed_app <- wait_list_app[app_owner];

  match some_confirmed_app with
  | Some confirmed_app =>
    delete wait_list_app[app_owner];

    SendApp confirmed_app app_owner;

    e = {
      _eventname : "ValidationAppSuccessEvent";
      app: confirmed_app;
      app_owner: app_owner
    };
    event e
  | None =>
    err = CodeNotFound;
    ThrowError err
  end
end

procedure ValidationAppReject(app_owner: ByStr20)
  delete wait_list_app[app_owner];

  e = {
    _eventname : "ValidationAppRejectEvent";
    app_owner: app_owner
  };
  event e
end

(* Admin transitions *)
transition ConfigurePause()
  IsContractOwner;
  curent_pause <- pause;

  new_pause = match curent_pause with
  | True =>
    False
  | False =>
    True
  end;

  pause := new_pause;

  e = {
    _eventname : "ContractPauseEvent";
    pause: new_pause
  };
  event e
end

transition ConfigureMinStake(value: Uint128)
  IsContractOwner;

  min_stake_amount := value;

  e = {
    _eventname : "ConfigureMinStakeEvent";
    min_stake_amount: value
  };
  event e
end

transition ConfigureManager(new_manager: ByStr20)
  IsContractOwner;

  manager := new_manager;

  e = {
    _eventname : "ConfigureManagerEvent";
    manager: new_manager
  };
  event e
end

transition RemoveValidator(address: ByStr20)
  IsContractOwner;

  some_amount <- holder_list[address];

  amount = option_uint128 zero128 some_amount;

  WithdrawZLP address
end

transition WithdrawSelf()
  IsContractOwner;

  some_balance <- holder_list[_this_address];

  balance = option_uint128 zero128 some_balance;

  UpdateZLP sub_operation _this_address balance balance;
  CallTransfer contract_owner balance
end

transition RemoveADList(ad_owners: List ByStr20)
  IsContractOwner;

  msg = {
    _tag : "RemoveADList";
    _recipient: explorer;
    _amount: Uint128 0;
    ad_owners: ad_owners
  };
  msgs = one_msg msg;
  send msgs
end

transition RemoveApp(category: Uint32, app_owner: ByStr20)
  IsContractOwner;

  msg = {
    _tag : "RemoveApp";
    _recipient: explorer;
    _amount: Uint128 0;
    category: category;
    app_owner: app_owner
  };
  msgs = one_msg msg;
  send msgs
end
(* Admin transitions *)

(* Validator transitions *)
transition AppSuccessList(app_owners: List ByStr20)
  CheckPause;
  IsValidator;

  forall app_owners ValidationAppSuccess
end

transition AppRejectList(app_owners: List ByStr20)
  CheckPause;
  IsValidator;

  forall app_owners ValidationAppReject
end

transition ADSuccessList(ad_owners: List ByStr20)
  CheckPause;
  IsValidator;

  forall ad_owners ValidationADSuccess
end

transition ADRejectList(ad_owners: List ByStr20)
  CheckPause;
  IsValidator;

  forall ad_owners ValidationADReject
end

transition WithdrawTokens(to: ByStr20)
  IsValidator;
  isOwnerOrOperator to;
  WithdrawZLP to
end
(* Validator transitions *)

(* manager transitions *)
transition AddApp(app: App, owner: ByStr20)
  CheckPause;
  IsManager;

  wait_list_app[owner] := app
end

transition AddAD(ad: AD, owner: ByStr20, amount: Uint128)
  CheckPause;
  IsManager;

  wait_ad_list[owner] := ad;
  ad_amount_list[owner] := amount
end
(* manager transitions *)

(* Callbacks *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
  IsZLP;
  CheckAmount amount;

  some_balance <- holder_list[sender];
  validators <- total_validators;

  balance = option_uint128 zero128 some_balance;
  new_validators = builtin add validators one128;
  total_validators := new_validators;

  UpdateZLP add_operation sender amount balance
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  IsZLP;

  address_manager <- manager;

  is_manager = builtin eq address_manager initiator;

  match is_manager with
  | True =>
  | False =>
    validators <- total_validators;
    some_balance <- holder_list[sender];

    new_validators = builtin add validators one128;
    balance = option_uint128 zero128 some_balance;

    CheckAmount amount;
    UpdateZLP add_operation sender amount balance;

    operators[sender] := initiator;
    total_validators := new_validators
  end
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end
(* Callbacks *)
